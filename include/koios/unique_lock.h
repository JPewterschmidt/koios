#ifndef KOIOS_UNIQUE_LOCK_H
#define KOIOS_UNIQUE_LOCK_H

#include <utility>
#include "koios/task.h"
#include "toolpex/move_only.h"

namespace koios
{

/*! \brief  The RAII object which holds the ownership of corresponding mutex. 
 *
 *  This type of object should be generated by a `koios::mutex` object.
 */
template<typename Mutex>
class unique_lock : public toolpex::move_only
{
private:
    template<typename T>
    friend class acq_lk_aw;

    unique_lock(Mutex& m) noexcept
        : m_mutex{ &m }
    {
    }

public:
    unique_lock() noexcept = default;

    unique_lock(unique_lock&& other) noexcept
        : m_mutex{ ::std::exchange(other.m_mutex, nullptr) }, 
          m_hold{ ::std::exchange(other.m_hold, false) }
    {
    }

    unique_lock& 
    operator=(unique_lock&& other) noexcept
    {
        unlock();

        m_mutex = ::std::exchange(other.m_mutex, nullptr);
        m_hold = ::std::exchange(other.m_hold, false);

        return *this;
    }

    /*! \brief Regain the ownership of the corresponding mutex (asynchronous) */
    task<> 
    lock()
    {
        if (!m_mutex) [[unlikely]]
            throw koios::exception{ "there's no corresponding mutex instance!" };

        auto lk = co_await m_mutex->acquire();

        assert(!is_hold());
        m_hold = ::std::exchange(lk.m_hold, false);
        assert(is_hold());

        co_return;
    }

    /*! \brief Give up the ownership of the corresponding mutex.
     *  
     *  After give up the ownership, you can `lock()`
     *  corresponding the corresponding mutex.
     */
    void unlock() noexcept
    {
        if (m_mutex && is_hold())
        {
            m_mutex->release();
            m_hold = false;
        }
    }

    /*! \brief Automatically release the ownership. */
    ~unique_lock() noexcept { unlock(); }

    bool is_hold() const noexcept { return m_hold; }

private:
    Mutex* m_mutex{};
    bool m_hold{ true };
};

} // namespace koios

#endif
